stuff...

Data Object for event Store
store: {
	'event:name': [
		{
			once: true/false
			, call: function(){}
			, scope: the this for this object
		}
	]
}

local events:
When triggered locally events only fire local listeners
the only difference is what store they are placed in.
The local store or the global store.

trace:
console.logs out the emitter of the event by looking up it's emitterId
Needs to have an emitterId registry, and search function...


SILENCE
-----------------------------------------------------

Calling the silence/silenceLocal function:
-----------------------------------------------------
object.silence('name:event')
	or
object.silence('name:event', function(){})
	or
object.silence('name:event', function(){}, scope)
	or
object.silence('name:event', function(){}, scope, once)
	or
object.silence('name:event', function(){}, scope, once, local)



Passing an Object into the silence/silenceLocal function:
-----------------------------------------------------
object.silence({
	eventName: 'name:event'
	, handler: function(){alert('word')}
	, scope: this
	, once: true/false
	, local: true/false
})



LISTEN
-----------------------------------------------------

Calling the listen function:
-----------------------------------------------------


Passing an Object into the listen function:
-----------------------------------------------------
object.listen({
	eventName: 'name:event'
	, handler: function(){}
	, scope: this
	, once: true/false
	, local: true/false
})


MODELS
-----------------------------------------------------
Models are responsible for getting themselves and for other operations that belong to them. They are encapsulated data holders. No rendering, just data. They have internal events that can be listened to (created, retrieved, updated, saved, destroyed) and they can trigger global events.

model structure looks like:
model: {
	emitterID
	attributes (private)
	get: function()
	set: function() (updates via an object or key value pair)
	flatten: function() (returns just the attributes)
	clear: function()
	destroy: function()
}



TODO list
	1. trace function and emitterId
	2. simplify and combine common functional elements to reduce this
	3. consider rearranging the params for silence
	4. make sure that all the cases are handled in silence with the ability to pass in an object
	5. prevent zombies
	6. integrate the dependency injection system from SM
	7. DOM rendering... maybe have this be up to the user what framework they use
	8. a way to retrieve the model from the server if wanted
	